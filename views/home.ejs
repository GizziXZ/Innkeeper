<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/home.css">
    <title>Home</title>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="chat-list">
                <h2>Direct Messages</h2>
                <ul>
                    <!-- <li>User</li> -->
                </ul>
                <div id="context-menu" class="context-menu">
                    <ul>
                        <li id="remove-friend" onclick="removeFriend()">Remove Friend</li>
                    </ul>
                </div>
            </div>
            <div class="user-actions">
                <h4><%=username%></h4>
                <button class="friends-button" onclick="friends()">Friend Requests <span class="notification-circle"></span></button>
                <button class="add-user-button" onclick="addUser()">Add User</button>
            </div>
        </aside>
        <main class="content">
            <header>
                <h1 id="currentChat"></h1>
                <div class="header-buttons">
                    <!-- <button onclick="window.location.href='/profile'">Profile</button> -->
                    <button onclick="window.location.href='/logout'">Logout</button>
                </div>
            </header>
            <section class="messages">
                <div class="welcome-message">
                    <h2>Welcome to Innkeeper!</h2>
                    <p>It looks like you haven't started a chat yet or you don't have any friends added.</p>
                    <p>Here are some tips to get started:</p>
                    <ul>
                        <li>Click on the "Add User" button to add new friends.</li>
                        <li>Once you have friends, click on their names to start chatting.</li>
                        <li>Use the "Friend Requests" button to manage your friend requests.</li>
                    </ul>
                    <button class="add-friend-button" onclick="addUser()">Add Your First Friend</button>
                </div>
                <!-- <div class="message">
                    <div class="message-header">
                        <span class="message-user">User1</span>
                        <span class="message-time">10:30 AM</span>
                    </div>
                    <p class="message-content">Hello!</p>
                </div> -->
            </section>
            <p id="typingIndicator"></p>
            <footer>
                <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" disabled>
                <input id="fileInput" type="file" accept="image/*,video/*" style="display: none;" onchange="uploadMedia(event)">
                <button id="upload" onclick="document.getElementById('fileInput').click()" disabled>+</button>
            </footer>
        </main>
    </div>

    <!-- Modals -->
    <div id="addUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Add User</h2>
            <input type="text" id="usernameInput" placeholder="Enter username" autocomplete="off">
            <button onclick="submitUser()" id="add-button">Add</button>
        </div>
    </div>

    <div id="friendsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Friend Requests</h2>
            <ul>
                <!-- <li>Request</li> -->
            </ul>
        </div>
    </div>

    <div id="mediaModal" class="modal">
        <!-- <span class="close" onclick="closeModal()">&times;</span> -->
        <!-- <img class="media-modal" id="modalImage"> -->
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script> // SECTION - Client-side JavaScript
        let refreshPromise = null;
        var socket = io({ // connect to the server
            auth: {
                token: document.cookie.split('=')[1]
            }
        });
        const { subtle } = window.crypto;
        let db;
        let userPrivateKey, userPublicKey;
        const messageInput = document.getElementById('messageInput');
        const messagesContainer = document.querySelector('.messages');

        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('innkeeper', 1);
                
                request.onupgradeneeded = (event) => { // create the database if it doesn't exist
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('keys')) {
                        db.createObjectStore('keys', { keyPath: 'username' });
                    }
                    if (!db.objectStoreNames.contains('messages')) {
                        db.createObjectStore('messages', { keyPath: 'username' });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function init() {
            try {
                db = await openDatabase();
                // console.log('Database loaded successfully');
            } catch (error) {
                console.error('Failed to load the database:', error);
            }
        }

        function savePrivateKey(username, privateKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const key = {
                username,
                privateKey
            };
            store.put(key);
        }

        function savePublicKey(friend, publicKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const keyData = {
                username: friend,
                publicKey
            };
            store.get(friend).onsuccess = (event) => {
                if (!event.target.result) return store.put(keyData);
                if (event.target.result.symmetricKey) keyData.symmetricKey = event.target.result.symmetricKey;
                store.put(keyData);
            };
        }

        async function createSymmetricKey(friend, publicKey) { // create a symmetric key for the chat with the friend
            publicKey = await subtle.importKey('jwk', publicKey, { // import the public key
                name: 'RSA-OAEP',
                hash: 'SHA-256',
            }, true, ['encrypt']);
            const symmetricKey = await subtle.generateKey({ // generate a symmetric key
                name: 'AES-GCM',
                length: 256,
            }, true, ['encrypt', 'decrypt']);
            const keyData = await subtle.exportKey('jwk', symmetricKey); // exported symmetric key
            const encryptedKeyData = await subtle.encrypt({ // encrypt the symmetric key with the friend's public key
                name: 'RSA-OAEP',
            }, publicKey, new TextEncoder().encode(JSON.stringify(keyData)));
            socket.emit('save-symmetric-key', encryptedKeyData, friend); // send the symmetric key to the server
            // save the symmetric key in indexedDB
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const data = {
                username: friend, // the username of the other user
                symmetricKey: keyData,
            };
            store.get(friend).onsuccess = (event) => {
                if (!event.target.result) return store.put(data);
                if (event.target.result.publicKey) data.publicKey = event.target.result.publicKey;
                store.put(data);
            }
            console.log('Creating symmetric key for ' + friend);
            return keyData; // dont think this i need this anymore tbh but whatever
        }

        function getMessageHTML(message) { // get the default HTML for a message
            let messageText = message.text;
            if (!message.sender) message.sender = document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent;
            if (!message.date) message.date = new Date();
            if (!message.media) message.media = '';
            if (!message.text) message.text = '';
            else messageText = linkify(message.text); // linkify the message

            function linkify(text) { // convert URLs in the message to clickable links
                const urlPattern = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig; // yeah btw i have no idea what this regex is, as far as i know it's just magic
                if (urlPattern.test(text)) {
                    if (text.includes('open.spotify.com')) { // spotify embed
                        const spotifyPattern = /https:\/\/open.spotify.com\/track\/([a-zA-Z0-9]+)(\?si=[a-zA-Z0-9]+)?/g;
                        return text.replace(spotifyPattern, '<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/$1" width="80%" height="152" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture;" loading="lazy"></iframe>');
                    }

                    // more embeds soon eventually. i tried to add tenor links but it's just not working
                }
                // if there's still a url pattern
                return text.replace(urlPattern, '<a href="$1" target="_blank">$1</a>');
            }

            let messageHTML = `<div class="message-header">
                    <span class="message-user">${message.sender}</span>
                    <span class="message-time">${message.date.toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })}</span>
                    </div>
                    <p class="message-content" id="${message.id}">${messageText}</p>`;
            if (message.media.startsWith('data:image/')) messageHTML = messageHTML + `<img src="${message.media}" style="max-width: 25vw; max-height: 25vh; object-fit: contain;">`;
            if (message.media.startsWith('data:video/')) messageHTML = messageHTML + `<video src="${message.media}" style="max-width: 30vw; max-height: 30vh; object-fit: contain;" controls></video>`;
            return messageHTML;
        }

        // i feel like the user being able to change the html and being upload another kind of file (that isnt an image) is some kind of security risk but i don't know

        function uploadMedia(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const media = event.target.result;
                const recipient = document.getElementById('currentChat').textContent;
                db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementById('currentChat').textContent).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the public key doesn't exist, don't send
                    const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                        name: 'AES-GCM',
                        length: 256,
                    }, true, ['encrypt', 'decrypt']);
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // generate an initialization vector
                    const encrypted = await subtle.encrypt({ // encrypt the media
                        name: 'AES-GCM',
                        iv
                    }, symmetricKey, new TextEncoder().encode(media));
                    let rawText;
                    let data = {
                        media: encrypted,
                        iv,
                        recipient,
                    };
                    if (messageInput.value) { // this is to send text and media at the same time
                        rawText = messageInput.value;
                        const encryptedText = await subtle.encrypt({  // encrypt the message
                            name: 'AES-GCM',
                            iv
                        }, symmetricKey, new TextEncoder().encode(messageInput.value));
                        data.text = String.fromCharCode.apply(null, new Uint8Array(encryptedText));
                    };
                    if (encrypted.byteLength > 1e7) return alert('File is too large!'); // if the file is too large, don't send it
                    socket.emit('message', data, (response) => {
                        if (response.error) return console.error('Failed to send image:', response.error);
                        messageInput.value = ''; // clear the input field
                        if (rawText) response.text = rawText;
                        // display the image
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('message');
                        response.media = media;
                        messageElement.innerHTML = getMessageHTML(response);
                        messagesContainer.appendChild(messageElement);
                        const imgElement = messageElement.querySelector('img');
                        if (imgElement) {
                            imgElement.addEventListener('load', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                        const videoElement = messageElement.querySelector('video');
                        if (videoElement) {
                            videoElement.addEventListener('loadedmetadata', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                        saveMessage(response, response.recipient);
                    })
                }
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // resetting the input value so the same file can be uploaded again
            return;
        }

        function messageError(message) {
            const currentChat = document.getElementById('currentChat').textContent;
            const messagehtml = document.getElementById(message.id)
            messagehtml.style.color = 'crimson';
            messagehtml.parentElement.getElementsByClassName('message-time')[0].textContent = '(Failed to send, try to open chat again)';
        }
        
        function saveMessage(message, username) { // save the message in the indexedDB (essentially local storage)
            const transaction = db.transaction(['messages'], 'readwrite');
            const store = transaction.objectStore('messages');
            const data = {
                username, // the username of the user that the messages are for
                messages: [message]
            };
            store.get(username).onsuccess = (event) => {
                if (event.target.result) {
                    data.messages = event.target.result.messages;
                    data.messages.push(message);
                }
                store.put(data);
            };
        }

        messageInput.addEventListener('keypress', (event) => { // send message when enter is pressed
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        messageInput.addEventListener('input', () => { // send typing event to server
            socket.emit('typing', document.getElementById('currentChat').textContent);
        });

        socket.emit('pending-key', (keys) => { // this should happen on connecting, it will send all the pending keys for the client to manage
            console.log(keys);
            keys.forEach(keyObject => {
                const friend = Object.keys(keyObject)[0];
                let key = keyObject[friend];
                key = new Uint8Array(atob(key).split('').map(c => c.charCodeAt(0))); // decoded key
                console.log(key);
            })
        });

        socket.on('public-key', async (data) => { // save the public key of the friend in the local storage
            const publicKey = JSON.parse(JSON.parse(data.publicKey)); // insert mandatory "WHY DO I HAVE TO PARSE THIS TWICE" comment here
            savePublicKey(data.friend, publicKey);
            createSymmetricKey(data.friend, publicKey); // create a symmetric key for the chat with the friend
        });

        socket.on('save-symmetric-key', async (encryptedKeyData, friend) => { // save the symmetric key in indexedDB (if you were sent the symmetric key)
            const symmetricKey = await subtle.decrypt({ // decrypt the symmetric key
                name: 'RSA-OAEP',
            }, userPrivateKey, encryptedKeyData).then(async decrypted => {
                decrypted = new TextDecoder().decode(decrypted);
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                const data = {
                    username: friend, // the username of the user that the messages are for
                    symmetricKey: JSON.parse(decrypted),
                };
                store.get(friend).onsuccess = (event) => {
                    if (!event.target.result) return store.put(data);
                    if (event.target.result) {
                        data.publicKey = event.target.result.publicKey;
                    }
                    store.put(data);
                };
            });
        })

        socket.on('message', async (message) => { // receive message from server
            if (message.recipient !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return; // don't do anything if it's not for the current user
            db.transaction(['keys'], 'readonly').objectStore('keys').get(message.sender).onsuccess = async (event) => {
                if (!event.target.result) return; // if the key doesn't exist, don't do anything
                // sometimes there'll be an error with no message attached, it's usually because of the decrypt() using the wrong key
                const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                    name: 'AES-GCM',
                    length: 256,
                }, true, ['encrypt', 'decrypt']);
                if (message.media) {
                    const decryptedImage = await subtle.decrypt({ // decrypt the image
                        name: 'AES-GCM',
                        iv: message.iv,
                    }, symmetricKey, new Uint8Array(message.media)).then(decrypted => {
                        decrypted = new TextDecoder().decode(decrypted);
                        message.media = decrypted; // set the image to the decrypted image (im still in shock that my code finally works)
                    });
                }
                if (message.text) {
                    message.text = new Uint8Array(message.text.split('').map(c => c.charCodeAt(0))); // decode the message
                    let decryptedMessage;
                    await subtle.decrypt({ // decrypt the message
                        name: 'AES-GCM',
                        length: 256,
                        iv: message.iv,
                    }, symmetricKey, message.text).then(decrypted => {
                        decryptedMessage = new TextDecoder().decode(decrypted);
                    });
                    decryptedMessage = decryptedMessage.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); // escape html characters to prevent an exploit
                    message.text = decryptedMessage;
                }
                message.date = new Date();
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                if (message.sender !== document.getElementById('currentChat').textContent && message.recipient !== document.getElementById('currentChat').textContent) { // if the message isn't from the current chat, don't show it but save it locally and add a notification circle
                    saveMessage(message, message.sender); // in this case, the sender is the other user and the recipient is the current user
                    const chatlist = document.querySelector('.chat-list ul');
                    const friends = chatlist.getElementsByTagName('li');
                    for (let i = 0; i < friends.length; i++) {
                        if (friends[i].textContent === message.sender) {
                            friends[i].getElementsByClassName('message-notification-circle')[0].style.visibility = 'visible';
                        }
                    }
                    return;
                }
                messageElement.innerHTML = getMessageHTML(message);
                messagesContainer.appendChild(messageElement);
                if (message.media) {
                    const imgElement = messageElement.querySelector('img');
                    if (imgElement) {
                        imgElement.addEventListener('load', () => {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                        });
                    }
                    const videoElement = messageElement.querySelector('video');
                    if (videoElement) {
                        videoElement.addEventListener('loadedmetadata', () => {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                        });
                    }
                } else messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when message is received
                saveMessage(message, message.sender); // since we already have an if statement to not do anything if the message isn't for the current user, we can just save the message with the sender as the chat
            }
        });

        let typingTimeout;
        socket.on('typing', (sender) => {
            if (sender !== document.getElementById('currentChat').textContent) return; // only show typing indicator if the sender is the current chat
            const typingIndicator = document.getElementById('typingIndicator');
            typingIndicator.innerText = `${sender} is typing...`;
            typingIndicator.style.display = 'block';

            // Clear any existing timeout to avoid flickering
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }

            // Hide the typing indicator after a few seconds
            typingTimeout = setTimeout(() => {
                typingIndicator.style.display = 'none';
            }, 2000);
        });

        socket.on('friend-request', () => { // show notification when friend request is received
            const notificationCircle = document.querySelector('.notification-circle');
            notificationCircle.style.display = 'block';
        });

        socket.on('refresh', () => { // refresh the chat list when a friend is removed or a request is accepted
            refresh();
        });

        socket.on('online', async (friend) => { // show online status when a friend is online
            if (refreshPromise) await refreshPromise;
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'green';
                }
            }
        });

        socket.on('offline', (friend) => { // show offline status when a friend is offline
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'white';
                }
            }
        });

        document.getElementsByClassName('messages')[0].addEventListener('click', () => { // focus on the chat input when clicking in the messages, for convenience
            messageInput.focus();
        })

        async function sendMessage() {
            let messageText = messageInput.value;
            if (messageText) {
                db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementById('currentChat').textContent).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the public key doesn't exist, don't send the message
                    const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                        name: 'AES-GCM',
                        length: 256,
                    }, true, ['encrypt', 'decrypt']);
                    const encodedMessage = new TextEncoder().encode(messageText); // encode the message (because apparently that's how you do it in subtlecrypto)
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // generate an initialization vector
                    const encrypted = await subtle.encrypt({  // encrypt the message
                        name: 'AES-GCM',
                        iv
                    }, symmetricKey, encodedMessage);
                    const data = {
                        text: String.fromCharCode.apply(null, new Uint8Array(encrypted)), // ngl i don't know what the fromCharCode.apply thing does but it works so i'm not gonna touch it
                        recipient: document.getElementById('currentChat').textContent,
                        iv
                    }
                    socket.emit('message', data, (response) => { // send message to server
                        if (response.text) { // change response texts back to messageText because the server sends the message back with the base64 encoded + encrypted message
                            response.text = messageText;
                        } else if (response.message && response.message.text) {
                            response.message.text = messageText;
                        }
                        if (response.error) { // if the message fails to send (according to the server)
                            console.error(response.error);
                            const message = response.message;
                            const messageElement = document.createElement('div');
                            messageElement.classList.add('message');
                            messageElement.innerHTML = getMessageHTML(message);
                            messagesContainer.appendChild(messageElement);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            messageInput.value = ''; // clear the input field
                            messageError(message);
                        } else { // if the message is sent successfully (hopefully)
                            const message = response;
                            const messageElement = document.createElement('div');
                            messageElement.classList.add('message');
                            messageElement.innerHTML = getMessageHTML(response);;
                            messagesContainer.appendChild(messageElement);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            messageInput.value = ''; // clear the input field
                            saveMessage(message, message.recipient); // saving the message, the recipient would be the other user and the sender would be the current user
                        }
                    });
                }
            }
        }

        async function refresh() {
            try {
                await init();
                refreshPromise = new Promise(async (resolve) => {
                const modal = document.getElementById('mediaModal');
                const modalMedia = document.createElement('div');
                modalMedia.id = 'modalMedia';
                document.body.addEventListener('click', (event) => { // "event delegation" or whatever the fuck that means
                    if (event.target.tagName === 'IMG' && event.target.id !== 'modalMedia') {
                        modal.style.display = 'block';
                        const img = document.createElement('img')
                        img.classList.add('media-modal')
                        img.src = event.target.src;
                        modal.appendChild(modalMedia).appendChild(img)
                    } else if (event.target === modal) {
                        modalMedia.replaceChildren('');
                        closeModal();
                    }
                });
                const username = document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent;
                db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                    if (!event.target.result) { // if the user isn't in store, generate a key pair
                        const keyPair = await subtle.generateKey({ // generate key pair (we will need to later make checks to see if the key pair doesn't exist and generate it if it doesn't + tell the server to send the public key to the friends)
                            name: 'RSA-OAEP',
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                            hash: 'SHA-256',
                        }, true, ["encrypt","decrypt"]);
                        userPrivateKey = keyPair.privateKey;
                        userPublicKey = keyPair.publicKey;
                        savePrivateKey(username, await subtle.exportKey('jwk', userPrivateKey));
                        console.log('Private key saved');
                        socket.emit('save-public-key', JSON.stringify(await subtle.exportKey('jwk', userPublicKey))); // send the public key to the server
                    } else { // if the user is in the store, load the key
                        db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                            if (!event.target.result) return;
                            userPrivateKey = await subtle.importKey('jwk', event.target.result.privateKey, {
                                name: 'RSA-OAEP',
                                hash: 'SHA-256',
                            }, true, ['decrypt']);
                            console.log('Private key loaded');
                        }
                    }
                }
                const chatlist = document.querySelector('.chat-list ul');
                const currentChat = document.getElementById('currentChat');
                // chatlist.innerHTML = ''; // Clear existing list items
                let response = await fetch('/friends', { // Fetch the list of friends from the server
                    method: 'GET',
                    credentials: "include",
                })
                
                if (!response.ok) {
                    throw new Error('Failed to fetch friends');
                }

                let friends = await response.json();
                await friends.forEach(friend => { // for every friend in the list, create a list item and append it to the chatlist
                    const transaction = db.transaction(['keys'], 'readonly');
                    const store = transaction.objectStore('keys');
                    const request = store.get(friend);
                    request.onsuccess = async (event) => { // check for a saved public key for the friend and request it if it doesn't exist
                        if (!event.target.result || !event.target.result.publicKey) {
                            socket.emit('request-public-key', friend);
                        }
                    };

                    const li = document.createElement('li');
                    const notificationCircle = document.createElement('span');
                    notificationCircle.classList.add('message-notification-circle');
                    notificationCircle.style.visibility = 'hidden';
                    li.textContent = friend;
                    li.addEventListener('click', async () => { // switch the chat to the selected friend
                        messageInput.removeAttribute('disabled'); // enable the message input field
                        document.getElementById('upload').removeAttribute('disabled'); // enable the upload button
                        document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when switching chats
                        currentChat.textContent = friend;
                        messagesContainer.innerHTML = ''; // Clear existing messages
                        const messagesTransaction = db.transaction(['messages'], 'readonly');
                        const messagesStore = messagesTransaction.objectStore('messages');
                        const messagesRequest = messagesStore.get(friend);

                        messagesRequest.onsuccess = (event) => { // after the messages are grabbed from storage, display them
                            if (!event.target.result) return;
                            const messages = event.target.result.messages || [];
                            messages.forEach(message => {
                                if (message.sender !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent && message.recipient !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return; // only show messages that are sent to or from the current user
                                const messageElement = document.createElement('div');
                                messageElement.classList.add('message');
                                messageElement.innerHTML = getMessageHTML(message);;
                                messagesContainer.appendChild(messageElement);
                                if (message.media) {
                                    const imgElement = messageElement.querySelector('img');
                                    if (imgElement) {
                                        imgElement.addEventListener('load', () => {
                                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                        });
                                    }
                                    const videoElement = messageElement.querySelector('video');
                                    if (videoElement) {
                                        videoElement.addEventListener('loadedmetadata', () => {
                                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                        });
                                    }
                                } else messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            });
                        };
                        notificationCircle.style.visibility = 'hidden'; // hide the notification circle when the chat is opened
                        messageInput.focus();
                    });
                    li.addEventListener('contextmenu', (event) => { // right click to open context menu
                        event.preventDefault();
                        const contextMenu = document.getElementById('context-menu');
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = event.clientX + 'px';
                        contextMenu.style.top = event.clientY + 'px';
                        contextMenu.friend = friend;
                    });
                    chatlist.appendChild(li);
                    li.appendChild(notificationCircle);
                });

                document.addEventListener('click', (event) => { // close context menu when clicking outside of it
                    const contextMenu = document.getElementById('context-menu');
                    if (event.target !== contextMenu && !contextMenu.contains(event.target)) {
                        contextMenu.style.display = 'none';
                    }
                });
                resolve();
                // doing this after the resolve because it's not necessary to wait for it
                response = await fetch('/friend-requests', { // i could probably just call the friends function here but i'd have to do scope stuff and who do you think i am, a professional?
                    method: 'GET',
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                friends = await response.json();
                const notificationCircle = document.querySelector('.notification-circle');
                if (friends.length > 0) { // if there are friend requests, display a notification circle
                    notificationCircle.style.display = 'block';
                } else {
                    notificationCircle.style.display = 'none';
                }
            })
            } catch (err) {
                console.error(err);
            }
        }

        async function friends() {
            document.getElementById('friendsModal').style.display = 'block'; // used to display the modal
            try {
                const response = await fetch('/friend-requests', { // Fetch the friend requests from the server
                    method: 'GET',
                    credentials: "include",
                });
                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                const friends = await response.json();
                const friendsList = document.querySelector('#friendsModal ul');
                friendsList.innerHTML = ''; // Clear existing list items

                friends.forEach(friend => { // for every friend in the list, create a list item and append it to the friendsList
                    const li = document.createElement('li');                    
                    li.textContent = friend;

                    const acceptButton = document.createElement('button');
                    acceptButton.textContent = 'Accept';
                    acceptButton.classList.add('friend-request-button', 'accept-button');
                    acceptButton.addEventListener('click', () => handleFriendRequest(friend, true));

                    const rejectButton = document.createElement('button');
                    rejectButton.textContent = 'Reject';
                    rejectButton.classList.add('friend-request-button', 'reject-button');
                    rejectButton.addEventListener('click', () => handleFriendRequest(friend, false));
                    
                    li.appendChild(acceptButton);
                    li.appendChild(rejectButton);
                    friendsList.appendChild(li);
                });

                if (friends.length === 0) { // if there are no friend requests, display a message
                    const li = document.createElement('li');
                    li.textContent = 'No friend requests';
                    friendsList.appendChild(li);
                    document.querySelector('.notification-circle').style.display = 'none'; // hide the notification circle
                }
            } catch (err) {
                console.error(err);
            }
        }

        async function handleFriendRequest(friend, accept) {
            try {
                const response = await fetch('/friend-requests', { // fetch the friend requests from the server
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(friend)}&accept=${accept}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to handle friend request');
                }

                const friendsList = document.querySelector('#friendsModal ul');
                friendsList.innerHTML = ''; // might not be necessary tbh
                friends(); // refresh the friend requests
                refresh(); // refresh the chat list
            } catch (err) {
                console.error(err);
            }
        }

        async function removeFriend(friend) {
            try {
                const contextMenu = document.getElementById('context-menu');
                const response = await fetch('/remove-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(contextMenu.friend)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to remove friend');
                }

                contextMenu.style.display = 'none';
                const chatlist = document.querySelector('.chat-list ul');
                chatlist.innerHTML = ''; // Clear existing list items
                refresh();
            } catch (err) {
                console.error(err);
            }
            
        }

        function addUser() { // used to display the add friend modal
            document.getElementById('addUserModal').style.display = 'block';
        }

        function closeModal() { // just closes the modals
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
            });
        }

        async function submitUser() { // used for adding friends
            const username = document.getElementById('usernameInput').value;
            if (username) {
                const response = await fetch('/add-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(username)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded', // applcation/json doesn't work, i don't know why, i don't care why, i just want it to work. it's 7:40 am and i haven't slept
                    },
                })
                
                if (response.ok) {
                    alert('User ' + username + ' added!');
                } else if (response.status === 404) {
                    alert('User ' + username + ' not found!');
                } else if (response.status === 400) {
                    alert('User ' + username + ' is already a friend!');
                } else {
                    alert('Error adding user ' + username);
                }
                closeModal();
            }
        }
        refresh(); // refresh the chat list
    </script>
</body>
</html>