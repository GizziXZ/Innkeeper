<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/home.css">
    <title>Home</title>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="chat-list">
                <h2>Direct Messages</h2>
                <ul>
                    <!-- <li>User</li> -->
                </ul>
                <div id="context-menu" class="context-menu">
                    <ul>
                        <li id="remove-friend" onclick="removeFriend()">Remove Friend</li>
                    </ul>
                </div>
            </div>
            <div class="user-actions">
                <h4><%=username%></h4>
                <button class="friends-button" onclick="friends()">Friend Requests <span class="notification-circle"></span></button>
                <button class="add-user-button" onclick="addUser()">Add User</button>
            </div>
        </aside>
        <main class="content">
            <header>
                <h1 id="currentChat"></h1>
                <div class="header-buttons">
                    <!-- <button onclick="window.location.href='/profile'">Profile</button> -->
                    <button onclick="window.location.href='/logout'">Logout</button>
                </div>
            </header>
            <section class="messages">
                <div class="welcome-message">
                    <h2>Welcome to Innkeeper!</h2>
                    <p>It looks like you haven't started a chat yet or you don't have any friends added.</p>
                    <p>Here are some tips to get started:</p>
                    <ul>
                        <li>Click on the "Add User" button to add new friends.</li>
                        <li>Once you have friends, click on their names to start chatting.</li>
                        <li>Use the "Friend Requests" button to manage your friend requests.</li>
                    </ul>
                    <button class="add-friend-button" onclick="addUser()">Add Your First Friend</button>
                </div>
                <!-- <div class="message">
                    <div class="message-header">
                        <span class="message-user">User1</span>
                        <span class="message-time">10:30 AM</span>
                    </div>
                    <p class="message-content">Hello!</p>
                </div> -->
            </section>
            <p id="typingIndicator"></p>
            <footer>
                <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" disabled>
            </footer>
        </main>
    </div>

    <!-- Modals -->
    <div id="addUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Add User</h2>
            <input type="text" id="usernameInput" placeholder="Enter username" autocomplete="off">
            <button onclick="submitUser()" id="add-button">Add</button>
        </div>
    </div>

    <div id="friendsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Friend Requests</h2>
            <ul>
                <!-- <li>Request</li> -->
            </ul>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script> // SECTION - Client-side JavaScript
        let refreshPromise = null;
        var socket = io({ // connect to the server
            auth: {
                token: document.cookie.split('=')[1]
            }
        });
        const { subtle } = window.crypto;
        let db;
        let userPrivateKey, userPublicKey;
        const messageInput = document.getElementById('messageInput');
        const messagesContainer = document.querySelector('.messages');

        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('innkeeper', 1);
                
                request.onupgradeneeded = (event) => { // create the database if it doesn't exist
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('keys')) {
                        db.createObjectStore('keys', { keyPath: 'username' });
                    }
                    if (!db.objectStoreNames.contains('messages')) {
                        db.createObjectStore('messages', { keyPath: 'username' });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function init() {
            try {
                db = await openDatabase();
                // console.log('Database loaded successfully');
            } catch (error) {
                console.error('Failed to load the database:', error);
            }
        }

        function savePrivateKey(username, privateKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const key = {
                username,
                privateKey
            };
            store.add(key);
        }

        function savePublicKey(friend, publicKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const keyData = {
                username: friend,
                publicKey
            };
            store.put(keyData);
        }
        
        function saveMessage(message) {
            const transaction = db.transaction(['messages'], 'readwrite');
            const store = transaction.objectStore('messages');
            const data = {
                username: message.chat, // chat is the username of the friend, so it's used as the key, I think this isn't really ideal though but it works
                messages: [message]
            };
            store.get(message.chat).onsuccess = (event) => {
                if (event.target.result) {
                    data.messages = event.target.result.messages;
                    data.messages.push(message);
                }
                store.put(data);
            };
        }

        messageInput.addEventListener('keypress', (event) => { // send message when enter is pressed
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        messageInput.addEventListener('input', () => { // send typing event to server
            socket.emit('typing', document.getElementById('currentChat').textContent);
        });

        socket.on('public-key', async (data) => { // save the public key of the friend in the local storage
            // console.log(JSON.stringify(data.publicKey));
            // let publicKeys = localStorage.getItem('publicKeys');
            // if (publicKeys) {
            //     publicKeys = JSON.parse(publicKeys);
            // } else {
            //     publicKeys = {};
            // }
            // publicKeys[data.friend] = data.publicKey;
            // localStorage.setItem('publicKeys', JSON.stringify(publicKeys));
            // console.log(localStorage.getItem('publicKeys'));
            // const publicKey = await subtle.importKey('jwk', JSON.parse(JSON.parse(data.publicKey)), { // WHY DO I HAVE TO PARSE THIS TWICE
            //     name: 'RSA-OAEP',
            //     hash: 'SHA-256',
            // }, true, ['encrypt'])
            const publicKey = JSON.parse(JSON.parse(data.publicKey));
            savePublicKey(data.friend, publicKey);
        });

        socket.on('message', async (message) => { // receive message from server
            if (message.recipient !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return; // don't decrypt it if it's for the other user
            console.log(message);
            const decodedMessage = atob(message.text);
            // console.log(decodedMessage);
            const encrypted = new Uint8Array(decodedMessage.split('').map(c => c.charCodeAt(0)));
            console.log(encrypted);
            userPrivateKey = await subtle.importKey('jwk', userPrivateKey, {
                name: 'RSA-OAEP',
                hash: 'SHA-256',
            }, true, ['decrypt'])
            console.log(userPrivateKey) // undefined?
            const decryptedMessage = await subtle.decrypt({ // decrypt the message
                name: 'RSA-OAEP',
            }, userPrivateKey, new Uint8Array(encrypted)).then(decrypted => {
                console.log('decrypt')
                new TextDecoder().decode(decrypted);
            });
            console.log(decryptedMessage);
            message.text = decryptedMessage;
            message.date = new Date();
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            if (message.sender !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) message.chat = message.recipient; // set the chat to the recipient if the message is from the other user (these circles i'm making are getting out of hand)
            if (message.sender !== document.getElementById('currentChat').textContent && message.recipient !== document.getElementById('currentChat').textContent) { // if the message isn't from the current chat, don't show it but save it locally and add a notification circle
                // const messages = JSON.parse(localStorage.getItem(message.sender)) || [];
                // messages.push(message);
                // localStorage.setItem(message.sender, JSON.stringify(messages));
                saveMessage(message);
                
                const chatlist = document.querySelector('.chat-list ul');
                const friends = chatlist.getElementsByTagName('li');
                for (let i = 0; i < friends.length; i++) {
                    if (friends[i].textContent === message.sender) {
                        friends[i].getElementsByClassName('message-notification-circle')[0].style.visibility = 'visible';
                    }
                }
                return;
            }
            messageElement.innerHTML = `<div class="message-header">
                        <span class="message-user">${message.sender}</span>
                        <span class="message-time">${new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })}</span>
                        </div>
                        <p class="message-content" id="${message.id}">${message.text}</p>`;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
            document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when message is received
            // save the messages locally instead of on the server for privacy
            // const currentChat = document.getElementById('currentChat').textContent;
            // const messages = JSON.parse(localStorage.getItem(currentChat)) || [];
            // messages.push(message);
            // localStorage.setItem(currentChat, JSON.stringify(messages));
            saveMessage(message);
        });

        // socket.on('message-error', (message) => { // if the message fails to send (according to the server) (subject to change)
        //     const currentChat = document.getElementById('currentChat').textContent;
        //     const messagehtml = document.getElementById(message.id)
        //     messagehtml.style.color = 'crimson';
        //     messagehtml.parentElement.getElementsByClassName('message-time')[0].textContent = '(Failed to send, try to open chat again)';
        //     // let messages = JSON.parse(localStorage.getItem(currentChat)) || [];
        //     db.transaction(['messages'], 'readwrite').objectStore('messages').get(currentChat).onsuccess = (event) => {
        //         if (!event.target.result) return;
        //         let messages = event.target.result.messages;
        //         const savedMessage = messages.find(m => m.id === message.id);
        //         messages = messages.filter(m => m.id !== message.id); // remove the message from the local storage
        //         // localStorage.setItem(currentChat, JSON.stringify(messages));
        //         db.transaction(['messages'], 'readwrite').objectStore('messages').put(currentChat, messages);
        //     };
        // });

        socket.on('typing', (sender) => {
            if (sender !== document.getElementById('currentChat').textContent) return; // only show typing indicator if the sender is the current chat
            const typingIndicator = document.getElementById('typingIndicator');
            typingIndicator.innerText = `${sender} is typing...`;
            typingIndicator.style.display = 'block';

            // Hide the typing indicator after a few seconds
            setTimeout(() => {
                typingIndicator.style.display = 'none';
            }, 3000);
        });

        socket.on('friend-request', () => { // show notification when friend request is received
            const notificationCircle = document.querySelector('.notification-circle');
            notificationCircle.style.display = 'block';
        });

        socket.on('refresh', () => { // refresh the chat list when a friend is removed or a request is accepted
            refresh();
        });

        socket.on('online', async (friend) => { // show online status when a friend is online
            if (refreshPromise) await refreshPromise;
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'green';
                }
            }
        });

        socket.on('offline', (friend) => { // show offline status when a friend is offline
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'white';
                }
            }
        });

        document.getElementsByClassName('messages')[0].addEventListener('click', () => { // focus on the chat input when clicking in the messages, for convenience
            messageInput.focus();
        })

        async function sendMessage() {
            const message = messageInput.value;
            if (message) {
                db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementById('currentChat').textContent).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the public key doesn't exist, don't send the message
                    event.target.result.publicKey.kty = 'RSA'
                    const publicKey = await subtle.importKey('jwk', event.target.result.publicKey, {
                        name: 'RSA-OAEP',
                        hash: 'SHA-256',
                    }, true, ['encrypt']);
                    const encrypted = await subtle.encrypt({
                        name: 'RSA-OAEP',
                    }, publicKey, new TextEncoder().encode(message)); // encrypt the message
                    console.log(new Uint8Array(encrypted));
                    socket.emit('message', { // send message to server
                        text: btoa(String.fromCharCode.apply(null, new Uint8Array(encrypted))),
                        sender: document.cookie.split('=')[1],
                        recipient: document.getElementById('currentChat').textContent,
                        chat: document.getElementById('currentChat').textContent,
                    });
                    // console.log(new Uint8Array(encrypted));
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message');
                    messageElement.innerHTML = `<div class="message-header">
                        <span class="message-user">${document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent}</span>
                        <span class="message-time">${new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })}</span>
                        </div>
                        <p class="message-content">${message}</p>`;
                    messagesContainer.appendChild(messageElement);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                    messageInput.value = ''; // clear the input field
                    const data = {
                        text: message,
                        sender: document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent,
                        recipient: document.getElementById('currentChat').textContent,
                        chat: document.getElementById('currentChat').textContent,
                    }
                    saveMessage(data);
                    console.log(data);
                }
            }
        }

        async function refresh() {
            try {
                await init();
                refreshPromise = new Promise(async (resolve) => {
                const username = document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent;
                let userKey;
                db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                if (!event.target.result) { // if the user isn't in store, generate a key pair
                    const keyPair = await subtle.generateKey({ // generate key pair (we will need to later make checks to see if the key pair doesn't exist and generate it if it doesn't + tell the server to send the public key to the friends)
                        name: 'RSA-OAEP',
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                        hash: 'SHA-256',
                    }, true, ["encrypt","decrypt"]);
                    userPrivateKey = keyPair.privateKey;
                    userPublicKey = keyPair.publicKey;
                    // let savedPrivateKeys = localStorage.getItem('userPrivateKey');
                    // if (savedPrivateKeys) {
                    //     savedPrivateKeys = JSON.parse(savedPrivateKeys);
                    // } else {
                    //     savedPrivateKeys = {};
                    // }
                    // savedPrivateKeys[username] = JSON.stringify(await subtle.exportKey('jwk', userPrivateKey)); // save the private key in the local storage
                    // localStorage.setItem('userPrivateKey', JSON.stringify(savedPrivateKeys)); // save the private key in the local storage
                    savePrivateKey(username, userPrivateKey);
                    console.log('Private key saved');
                    socket.emit('save-public-key', JSON.stringify(await subtle.exportKey('jwk', userPublicKey))); // send the public key to the server
                } else {
                    // console.log(JSON.parse(localStorage.getItem('userPrivateKey'))[username]);
                    db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                        if (!event.target.result) return;
                        userPrivateKey = await subtle.exportKey('jwk', event.target.result.privateKey);
                        console.log('Private key loaded');
                    }
                }
                }
                const chatlist = document.querySelector('.chat-list ul');
                const currentChat = document.getElementById('currentChat');
                // chatlist.innerHTML = ''; // Clear existing list items
                let response = await fetch('/friends', { // Fetch the list of friends from the server
                    method: 'GET',
                    credentials: "include",
                })
                
                if (!response.ok) {
                    throw new Error('Failed to fetch friends');
                }

                let friends = await response.json();
                await friends.forEach(friend => { // for every friend in the list, create a list item and append it to the chatlist
                    // const localStorageFriend = localStorage.getItem(friend);
                    // if (!localStorageFriend || !JSON.parse(localStorageFriend).publicKey) socket.emit('request-public-key', friend); // check for a saved public key for the friend and request it if it doesn't exist
                    const transaction = db.transaction(['keys'], 'readonly');
                    const store = transaction.objectStore('keys');
                    const request = store.get(friend);
                    request.onsuccess = async (event) => {
                        if (!event.target.result) {
                            socket.emit('request-public-key', friend);
                        }
                    };

                    const li = document.createElement('li');
                    const notificationCircle = document.createElement('span');
                    notificationCircle.classList.add('message-notification-circle');
                    notificationCircle.style.visibility = 'hidden';
                    li.textContent = friend;
                    li.addEventListener('click', async () => { // switch the chat to the selected friend
                        messageInput.removeAttribute('disabled'); // enable the message input field
                        document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when switching chats
                        currentChat.textContent = friend;
                        messagesContainer.innerHTML = ''; // Clear existing messages
                        // const messages = JSON.parse(localStorage.getItem(friend)) || []; // load the messages from the local storage
                        const messagesTransaction = db.transaction(['messages'], 'readonly');
                        const messagesStore = messagesTransaction.objectStore('messages');
                        const messagesRequest = messagesStore.get(friend);

                        messagesRequest.onsuccess = (event) => { // after the messages are grabbed from storage, display them
                            if (!event.target.result) return;
                            const messages = event.target.result.messages || [];
                            messages.forEach(message => {
                                if (message.sender !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent && message.recipient !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return; // only show messages that are sent to or from the current user
                                const messageElement = document.createElement('div');
                                messageElement.classList.add('message');
                                messageElement.innerHTML = `<div class="message-header">
                                    <span class="message-user">${message.sender}</span>
                                    <span class="message-time">${new Date(message.date).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })}</span>
                                    </div>
                                    <p class="message-content">${message.text}</p>`;
                                messagesContainer.appendChild(messageElement);
                            });
                            notificationCircle.style.visibility = 'hidden'; // hide the notification circle when the chat is opened
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            messageInput.focus();
                        };
                    });
                    li.addEventListener('contextmenu', (event) => { // right click to open context menu
                        event.preventDefault();
                        const contextMenu = document.getElementById('context-menu');
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = event.clientX + 'px';
                        contextMenu.style.top = event.clientY + 'px';
                        contextMenu.friend = friend;
                    });
                    chatlist.appendChild(li);
                    li.appendChild(notificationCircle);
                });

                document.addEventListener('click', (event) => { // close context menu when clicking outside of it
                    const contextMenu = document.getElementById('context-menu');
                    if (event.target !== contextMenu && !contextMenu.contains(event.target)) {
                        contextMenu.style.display = 'none';
                    }
                });
                resolve();
                // doing this after the resolve because it's not necessary to wait for it
                response = await fetch('/friend-requests', { // i could probably just call the friends function here but i'd have to do scope stuff and who do you think i am, a professional?
                    method: 'GET',
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                friends = await response.json();
                const notificationCircle = document.querySelector('.notification-circle');
                if (friends.length > 0) { // if there are friend requests, display a notification circle
                    notificationCircle.style.display = 'block';
                } else {
                    notificationCircle.style.display = 'none';
                }
            })
            } catch (err) {
                console.error(err);
            }
        }

        async function friends() {
            document.getElementById('friendsModal').style.display = 'block'; // used to display the modal
            try {
                const response = await fetch('/friend-requests', { // Fetch the friend requests from the server
                    method: 'GET',
                    credentials: "include",
                });
                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                const friends = await response.json();
                const friendsList = document.querySelector('#friendsModal ul');
                friendsList.innerHTML = ''; // Clear existing list items

                friends.forEach(friend => { // for every friend in the list, create a list item and append it to the friendsList
                    const li = document.createElement('li');                    
                    li.textContent = friend;

                    const acceptButton = document.createElement('button');
                    acceptButton.textContent = 'Accept';
                    acceptButton.classList.add('friend-request-button', 'accept-button');
                    acceptButton.addEventListener('click', () => handleFriendRequest(friend, true));

                    const rejectButton = document.createElement('button');
                    rejectButton.textContent = 'Reject';
                    rejectButton.classList.add('friend-request-button', 'reject-button');
                    rejectButton.addEventListener('click', () => handleFriendRequest(friend, false));
                    
                    li.appendChild(acceptButton);
                    li.appendChild(rejectButton);
                    friendsList.appendChild(li);
                });

                if (friends.length === 0) { // if there are no friend requests, display a message
                    const li = document.createElement('li');
                    li.textContent = 'No friend requests';
                    friendsList.appendChild(li);
                    document.querySelector('.notification-circle').style.display = 'none'; // hide the notification circle
                }
            } catch (err) {
                console.error(err);
            }
        }

        async function handleFriendRequest(friend, accept) {
            try {
                const response = await fetch('/friend-requests', { // fetch the friend requests from the server
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(friend)}&accept=${accept}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to handle friend request');
                }

                const friendsList = document.querySelector('#friendsModal ul');
                friendsList.innerHTML = ''; // might not be necessary tbh
                friends(); // refresh the friend requests
                refresh(); // refresh the chat list
            } catch (err) {
                console.error(err);
            }
        }

        async function removeFriend(friend) {
            try {
                const contextMenu = document.getElementById('context-menu');
                const response = await fetch('/remove-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(contextMenu.friend)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to remove friend');
                }

                contextMenu.style.display = 'none';
                const chatlist = document.querySelector('.chat-list ul');
                chatlist.innerHTML = ''; // Clear existing list items
                refresh();
            } catch (err) {
                console.error(err);
            }
            
        }

        function addUser() { // used to display the add friend modal
            document.getElementById('addUserModal').style.display = 'block';
        }

        function closeModal() { // just closes the modals
            document.getElementById('addUserModal').style.display = 'none';
            document.getElementById('friendsModal').style.display = 'none';
        }

        async function submitUser() { // used for adding friends
            const username = document.getElementById('usernameInput').value;
            if (username) {
                const response = await fetch('/add-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(username)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded', // applcation/json doesn't work, i don't know why, i don't care why, i just want it to work. it's 7:40 am and i haven't slept
                    },
                })
                
                if (response.ok) {
                    alert('User ' + username + ' added!');
                } else if (response.status === 404) {
                    alert('User ' + username + ' not found!');
                } else if (response.status === 400) {
                    alert('User ' + username + ' is already a friend!');
                } else {
                    alert('Error adding user ' + username);
                }
                closeModal();
            }
        }
        refresh(); // refresh the chat list
    </script>
</body>
</html>