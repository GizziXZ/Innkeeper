<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/home.css">
    <title>Home</title>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="chat-list">
                <h2>Direct Messages</h2>
                <ul>
                    <!-- <li>User</li> -->
                </ul>
                <div id="friend-context-menu" class="context-menu">
                    <ul>
                        <li id="remove-friend" onclick="removeFriend()">Remove Friend</li>
                        <li id="block-user" onclick="blockUser()">Block User</li>
                    </ul>
                </div>
                <div id="group-context-menu" class="context-menu">
                    <ul>
                        <li id="leave-groupchat" onclick="leaveGroupchat()">Leave Groupchat</li>
                    </ul>
                </div>
            </div>
            <div class="user-actions">
                <h4 onclick="Profile()"><%=username%></h4>
                <button class="friends-button" onclick="friends()">Friend Requests <span class="notification-circle"></span></button>
                <button class="add-user-button" onclick="addUser()">Add User</button>
                <button class="blocked-users-button" onclick="blockedUsers()">Blocked</button>
            </div>
        </aside>
        <main class="content">
            <header>
                <h1 id="currentChat"></h1><p id="status"></p>
                <div class="header-buttons">
                    <div class="dropdown">
                        <button id="create-gc" style="display: none;" onclick="toggleDropdown()">Create Groupchat</button>
                        <div id="dropdown-content" class="dropdown-content" style="display: none;">
                            <p>Friends:</p>
                            <form id="friends-form"></form>
                            <button onclick="createGroupchat()">Create</button>
                        </div>
                    </div>
                    <!-- <button onclick="Profile()">Profile</button> -->
                    <button onclick="settings()">Settings</button>
                    <button onclick="window.location.href='/logout'">Logout</button>
                </div>
            </header>
            <section class="messages">
                <div class="welcome-message">
                    <h2>Welcome to Innkeeper!</h2>
                    <p>It looks like you haven't started a chat yet or you don't have any friends added.</p>
                    <p>Here are some tips to get started:</p>
                    <ul>
                        <li>Click on the "Add User" button to add new friends.</li>
                        <li>Once you have friends, click on their names to start chatting.</li>
                        <li>Use the "Friend Requests" button to manage your friend requests.</li>
                    </ul>
                    <button class="add-friend-button" onclick="addUser()">Add Your First Friend</button>
                </div>
                <!-- <div class="message">
                    <div class="message-header">
                        <span class="message-user">User1</span>
                        <span class="message-time">10:30 AM</span>
                    </div>
                    <p class="message-content">Hello!</p>
                </div> -->
            </section>
            <p id="typingIndicator"></p>
            <footer>
                <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" disabled>
                <a id="emojis" onclick="toggleEmojiPicker()">üó£Ô∏è</a>
                <input id="fileInput" type="file" accept="image/*,video/*" style="display: none;" onchange="uploadMedia(event)">
                <button id="upload" onclick="document.getElementById('fileInput').click()" disabled>+</button>
                <div id="emoji-picker" class="emoji-picker" style="display: none;">
                    <input type="text" id="emoji-search" placeholder="Search emojis..." oninput="filterEmojis()">
                    <div id="emoji-list"></div>
                </div>
            </footer>
        </main>
    </div>

    <!-- Modals -->
    <div id="profileModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Your Profile</h2>
            <h3>
                Profile picture: <input type="file" id="profilePicture" accept="image/*" onchange="uploadProfilePicture(event)"><br>
                <img id="profilePicturePreview" style="max-width: 100px; max-height: 100px; border-radius: 50%; object-fit: contain; float: left; margin-right: 10px;"><br>
                Set a custom status: <input type="text" id="statusInput" placeholder="Enter status" autocomplete="off" maxlength="64" onblur="saveStatus()">
            </h3>
        </div>
    </div>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Settings</h2>
            <h3>
                Auto-delete messages after: <select id="autoDeleteMessages" onchange="saveOptions()" class="option">
                <option value="never">Never</option>
                <option value="1h">1 hour</option>
                <option value="6h">6 hours</option>
                <option value="12h">12 hours</option>
                <option value="1d">1 day</option>
                <option value="1w">1 week</option></select>
            </h3>
        </div>
    </div>

    <div id="addUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Add User</h2>
            <input type="text" id="usernameInput" placeholder="Enter username" autocomplete="off">
            <button onclick="submitUser()" id="add-button">Add</button>
        </div>
    </div>

    <div id="friendsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Friend Requests</h2>
            <ul>
                <!-- <li>Request</li> -->
            </ul>
        </div>
    </div>

    <div id="blockedModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>Blocked Users</h2>
            <ul>
                <!-- <li>Blocked</li> -->
            </ul>
        </div>
    </div>

    <div id="mediaModal" class="modal">
        <!-- <img class="media-modal" id="modalImage"> -->
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@twemoji/api@latest/dist/twemoji.min.js" crossorigin="anonymous"></script>
    <script> // SECTION - Client-side JavaScript
        let refreshPromise = null;
        var socket = io({ // connect to the server
            auth: {
                token: document.cookie.split('=')[1]
            }
        });
        const { subtle } = window.crypto;
        let localFriends = []; // array to store friends locally
        const profilePicturesCache = {}; // cache for profile pictures
        let db;
        let userPrivateKey, userPublicKey;
        const messageInput = document.getElementById('messageInput');
        const messagesContainer = document.querySelector('.messages');

        document.addEventListener('DOMContentLoaded', populateEmojiPicker);

        twemoji.parse(document.getElementById('emojis'), {
            folder: 'svg',
            ext: '.svg'
        });

        document.getElementsByClassName('messages')[0].addEventListener('click', () => { // focus on the chat input when clicking in the messages, for convenience
            messageInput.focus();
        });

        messageInput.addEventListener('keypress', (event) => { // send message when enter is pressed
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        messageInput.addEventListener('input', () => { // send typing event to server
            socket.emit('typing', document.getElementById('currentChat').textContent);
        });

        // SECTION - initialization functions
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('innkeeper', 1);
                
                request.onupgradeneeded = (event) => { // create the database if it doesn't exist
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('keys')) {
                        db.createObjectStore('keys', { keyPath: 'username' });
                    }
                    if (!db.objectStoreNames.contains('messages')) {
                        db.createObjectStore('messages', { keyPath: 'username' });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function init() {
            try {
                db = await openDatabase();
                checkExpiredMessages(); // check for expired messages on initialization
                const transaction = db.transaction(['keys'], 'readonly');
                const store = transaction.objectStore('keys');
                const users = store.getAll();
                users.onsuccess = (event) => {
                    const result = event.target.result;
                    result.forEach(user => { // we're trying to get all the saved groupchats to join their rooms
                        if (user.type !== 'group') return;
                        socket.emit('join-groupchat', user.username, (response) => {
                            if (response.error) return console.error(response.error);
                            if (response.success) console.log('Joined groupchat:', user.username);
                        });
                    });
                };

                // cache the user's profile picture
                if (!profilePicturesCache[document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent]) {
                        try {
                        const response = await fetch('/profile-picture', {
                            method: 'GET',
                            credentials: "include",
                        });

                        if (!response.ok) {
                            throw new Error('Failed to load profile picture');
                        }

                        const data = await response.json();
                        const dataUrl = `data:${data.mimetype};base64,${data.data}`;
                        profilePicturesCache[document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent] = dataUrl;
                        return dataUrl;
                    } catch (err) {
                        console.error('Error loading profile picture:', err);
                    }
                }
                // console.log('Database loaded successfully');
            } catch (error) {
                console.error('Failed to load the database:', error);
            }
        }
        //!SECTION
        
        // SECTION - socket.io event listeners
        socket.on('connect', () => {
            socket.emit('pending-key', (keys) => { // on connection, get the pending keys from the server
                keys.forEach(async keyObject => {
                    const friend = Object.keys(keyObject)[0];
                    let key = keyObject[friend];
                    key = new Uint8Array(atob(key).split('').map(c => c.charCodeAt(0))); // decoded key
                    key = await subtle.decrypt({ // decrypt the key
                        name: 'RSA-OAEP',
                    }, userPrivateKey, key)
                    const transaction = db.transaction(['keys'], 'readwrite');
                    const store = transaction.objectStore('keys');
                    const data = {
                        username: friend,
                        symmetricKey: JSON.parse(new TextDecoder().decode(key)),
                    };
                    store.get(friend).onsuccess = (event) => {
                        if (!event.target.result) return store.put(data);
                        if (event.target.result) {
                            data.publicKey = event.target.result.publicKey;
                        }
                        store.put(data);
                    };
                });
            });
        });

        socket.on('join-groupchat', async (room, key) => { // this is for when the user joins a groupchat while they're online
            key = key.key; // get the key from the object
            await subtle.decrypt({ // decrypt the key
                name: 'RSA-OAEP',
            }, userPrivateKey, key).then(decrypted => {
                decrypted = JSON.parse(new TextDecoder().decode(decrypted));
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                const data = {
                    username: room,
                    symmetricKey: decrypted,
                    type: 'group'
                };
                store.put(data);
                refresh();
            });
        });

        socket.on('save-symmetric-key', async (encryptedKeyData, friend) => { // save the symmetric key in indexedDB (if you were sent the symmetric key)
            const symmetricKey = await subtle.decrypt({ // decrypt the symmetric key
                name: 'RSA-OAEP',
            }, userPrivateKey, encryptedKeyData).then(async decrypted => {
                decrypted = new TextDecoder().decode(decrypted);
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                const data = {
                    username: friend, // the username of the user that the messages are for
                    symmetricKey: JSON.parse(decrypted),
                };
                store.get(friend).onsuccess = (event) => {
                    if (!event.target.result) return store.put(data);
                    if (event.target.result) {
                        data.publicKey = event.target.result.publicKey;
                    }
                    store.put(data);
                };
            });
        });

        socket.on('message', async (message) => { // receive message from server
            if (message.recipient.includes('-')) { // if the recipient is a groupchat
                message = await receiveMessage(message, message.recipient);
                if (!message) return; // because of some fuckery going on inside the receiveMessage function where it returns if current user and rgajoajgoejgvroaejvavaorkpak
                saveMessage(message, message.recipient);
            } else {
                message = await receiveMessage(message, message.sender);
                saveMessage(message, message.sender);
            }
        });

        let typingTimeout;
        socket.on('typing', (sender) => {
            if (sender !== document.getElementById('currentChat').textContent) return; // only show typing indicator if the sender is the current chat
            const typingIndicator = document.getElementById('typingIndicator');
            typingIndicator.innerText = `${sender} is typing...`;
            typingIndicator.style.display = 'block';

            // Clear any existing timeout to avoid flickering
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }

            // Hide the typing indicator after a few seconds
            typingTimeout = setTimeout(() => {
                typingIndicator.style.display = 'none';
            }, 2000);
        });

        socket.on('friend-request', () => { // show notification when friend request is received
            const notificationCircle = document.querySelector('.notification-circle');
            notificationCircle.style.display = 'block';
        });

        socket.on('refresh', () => { // refresh the chat list when a friend is removed or a request is accepted
            refresh();
        });

        socket.on('online', async (friend) => { // show online status when a friend is online
            if (refreshPromise) await refreshPromise;
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'green';
                }
            }
        });

        socket.on('offline', (friend) => { // show offline status when a friend is offline
            const chatlist = document.querySelector('.chat-list ul');
            const friends = chatlist.getElementsByTagName('li');
            for (let i = 0; i < friends.length; i++) {
                if (friends[i].textContent === friend) {
                    friends[i].style.color = 'white';
                }
            }
        });

        socket.on('status-update', (updatedStatus) => sessionStorage.setItem(updatedStatus.user, updatedStatus.status)); // updatedStatus is an object
        //!SECTION

        function savePrivateKey(username, privateKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const key = {
                username,
                privateKey
            };
            store.put(key);
        }

        function savePublicKey(friend, publicKey) {
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const keyData = {
                username: friend,
                publicKey
            };
            store.get(friend).onsuccess = (event) => {
                if (!event.target.result) return store.put(keyData);
                if (event.target.result.symmetricKey) keyData.symmetricKey = event.target.result.symmetricKey;
                store.put(keyData);
            };
        }

        async function createSymmetricKey(friend, publicKey) { // create a symmetric key for the chat with the friend
            publicKey = await subtle.importKey('jwk', publicKey, { // import the public key
                name: 'RSA-OAEP',
                hash: 'SHA-256',
            }, true, ['encrypt']);
            const symmetricKey = await subtle.generateKey({ // generate a symmetric key
                name: 'AES-GCM',
                length: 256,
            }, true, ['encrypt', 'decrypt']);
            const keyData = await subtle.exportKey('jwk', symmetricKey); // exported symmetric key
            const encryptedKeyData = await subtle.encrypt({ // encrypt the symmetric key with the friend's public key
                name: 'RSA-OAEP',
            }, publicKey, new TextEncoder().encode(JSON.stringify(keyData)));
            socket.emit('save-symmetric-key', encryptedKeyData, friend); // send the symmetric key to the server to send to the friend
            // save the symmetric key in indexedDB
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            const data = {
                username: friend, // the username of the other user
                symmetricKey: keyData,
            };
            store.get(friend).onsuccess = (event) => {
                if (!event.target.result) return store.put(data);
                if (event.target.result.publicKey) data.publicKey = event.target.result.publicKey;
                store.put(data);
            }
            console.log('Creating symmetric key for ' + friend);
            return keyData; // dont think this i need this anymore tbh but whatever
        }

        function getMessageHTML(message) { // get the default HTML for a message
            let messageText = message.text;
            if (!message.sender) message.sender = document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent;
            if (!message.date) message.date = new Date();
            if (!message.media) message.media = '';
            if (!message.text) message.text = '';
            else messageText = linkify(message.text); // linkify the message

            function linkify(text) { // convert URLs in the message to clickable links
                const urlPattern = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig; // yeah btw i have no idea what this regex is, as far as i know it's just magic
                if (urlPattern.test(text)) {
                    if (text.includes('open.spotify.com')) { // spotify embed
                        const spotifyPattern = /https:\/\/open.spotify.com\/track\/([a-zA-Z0-9]+)(\?si=[a-zA-Z0-9]+)?/g;
                        return text.replace(spotifyPattern, '<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/$1" width="80%" height="152" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture;" loading="lazy"></iframe>');
                    }

                    // more embeds soon eventually. i tried to add tenor links but it's just not working
                }
                // if there's still a url pattern
                return text.replace(urlPattern, '<a href="$1" target="_blank">$1</a>');
            }

            const profilePictureData = profilePicturesCache[message.sender];
            const profilePictureHTML = profilePictureData ? `<img src="${profilePictureData}" style="width: 40px; height: 40px; border-radius: 50%;">` : '';

            let messageHTML = `<div class="message-header">
                ${profilePictureHTML}
                <span class="message-user">${message.sender}</span>
                <span class="message-time">${message.date.toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true })}</span>
                </div>
                <p class="message-content" id="${message.id}">${messageText}</p>`;
            if (message.media.startsWith('data:image/')) messageHTML = messageHTML + `<img src="${message.media}" style="max-width: 25vw; max-height: 25vh; object-fit: contain;">`;
            if (message.media.startsWith('data:video/')) messageHTML = messageHTML + `<video src="${message.media}" style="max-width: 30vw; max-height: 30vh; object-fit: contain;" controls></video>`;
            return messageHTML;
        }

        // i feel like the user being able to change the html and being upload another kind of file (that isnt an image) is some kind of security risk but i don't know

        function uploadMedia(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const media = event.target.result;
                const recipient = document.getElementById('currentChat').textContent;
                db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementById('currentChat').textContent).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the public key doesn't exist, don't send
                    const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                        name: 'AES-GCM',
                        length: 256,
                    }, true, ['encrypt', 'decrypt']);
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // generate an initialization vector
                    const encrypted = await subtle.encrypt({ // encrypt the media
                        name: 'AES-GCM',
                        iv
                    }, symmetricKey, new TextEncoder().encode(media));
                    let rawText;
                    let data = {
                        media: encrypted,
                        iv,
                        recipient,
                    };
                    if (messageInput.value) { // this is to send text and media at the same time
                        rawText = messageInput.value;
                        const encryptedText = await subtle.encrypt({  // encrypt the message
                            name: 'AES-GCM',
                            iv
                        }, symmetricKey, new TextEncoder().encode(messageInput.value));
                        data.text = String.fromCharCode.apply(null, new Uint8Array(encryptedText));
                    };
                    if (encrypted.byteLength > 1e7) return alert('File is too large!'); // if the file is too large, don't send it
                    socket.emit('message', data, async (response) => {
                        if (response.error) return console.error('Failed to send image:', response.error);
                        messageInput.value = ''; // clear the input field
                        if (rawText) response.text = rawText;
                        // display the image
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('message');
                        response.media = media;
                        messageElement.innerHTML = getMessageHTML(response);
                        twemoji.parse(messageElement, {
                            folder: 'svg',
                            ext: '.svg'
                        });
                        messagesContainer.appendChild(messageElement);
                        const imgElement = messageElement.querySelector('img');
                        if (imgElement) {
                            imgElement.addEventListener('load', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                        const videoElement = messageElement.querySelector('video');
                        if (videoElement) {
                            videoElement.addEventListener('loadedmetadata', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                        saveMessage(response, response.recipient);
                    })
                }
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // resetting the input value so the same file can be uploaded again
            return;
        }

        async function uploadProfilePicture(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.size > 5 * 1024 * 1024) {
                event.target.value = '';
                return alert('File is larger than 5MB');
            }

            // showing the image preview in the modal
            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.getElementById('profilePicturePreview');
                preview.src = e.target.result;
                preview.style.display = 'block';
            };
            reader.readAsDataURL(file);

            const formData = new FormData();
            formData.append('profilePicture', file);

            try {
                const response = await fetch('/upload-profile-picture', {
                    method: 'POST',
                    body: formData,
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to upload profile picture');
                }

                const data = await response.json();
                const profilePictureUrl = data.url;
                document.getElementById('profilePicturePreview').src = profilePictureUrl;
            } catch (err) {
                console.error('Error uploading profile picture:', err);
            }
        }

        async function createGroupchat() {
            const selected = document.getElementById('friends-form').querySelectorAll('input[type="checkbox"]:checked')
            const selectedFriends = Array.from(selected).map(checkbox => checkbox.value);
            if (selectedFriends.length < 2) return alert('Please select at least two friend to create a groupchat with'); // we are checking for atleast 2 friends anyways on the server side but its good to do this here too to save resources
            // for every friend, we will be getting their public keys, encrypting the symmetric key with their public key and sending it to them through the server. this is probably very resource intensive but it's the only secure way to do it
            const symmetricKey = await subtle.exportKey('jwk', await subtle.generateKey({ // generate a symmetric key for the groupchat
                name: 'AES-GCM',
                length: 256,
            }, true, ['encrypt', 'decrypt']));
            let selectedKeys = {}; // { "user1": "key1", "user2": "key2" }
            await Promise.all(selectedFriends.map(async friend => {
                let publicKey = await new Promise((resolve, reject) => {
                    const request = db.transaction(['keys'], 'readonly').objectStore('keys').get(friend);
                    request.onsuccess = (event) => {
                        if (!event.target.result) {
                            socket.emit('request-public-key', friend, (response) => {
                                if (response.error) return alert(response.error);
                                resolve(response);
                                const publicKey = JSON.parse(JSON.parse(response.publicKey)); // insert mandatory "WHY DO I HAVE TO PARSE THIS TWICE" comment here
                                savePublicKey(friend, publicKey); // save the public key in indexedDB
                            });
                            return;
                        }
                        resolve(event.target.result.publicKey);
                    };
                });
                
                publicKey = await subtle.importKey('jwk', publicKey, {
                    name: 'RSA-OAEP',
                    hash: 'SHA-256',
                }, true, ['encrypt']);
                
                const encryptedKeyData = await subtle.encrypt({
                    name: 'RSA-OAEP',
                }, publicKey, new TextEncoder().encode(JSON.stringify(symmetricKey)));
                
                selectedKeys[friend] = encryptedKeyData;
            }));
            socket.emit('create-groupchat', (selectedKeys), (response) => {
                if (response.error) return alert(response.error);
                document.getElementById('dropdown-content').style.display = 'none'; // close back the dropdown
                if (response) {
                    // save the groupchat in indexedDB first
                    const transaction = db.transaction(['keys'], 'readwrite');
                    const store = transaction.objectStore('keys');
                    const data = {
                        username: response, // response is the name of the groupchat/room
                        symmetricKey,
                        type: 'group' // used for identification
                    };
                    store.put(data);
                    refresh(); // refresh to show the new groupchat
                }
            });
        }

        function messageError(message) {
            const currentChat = document.getElementById('currentChat').textContent;
            const messagehtml = document.getElementById(message.id)
            messagehtml.style.color = 'crimson';
            messagehtml.parentElement.getElementsByClassName('message-time')[0].textContent = '(Failed to send, try to open chat again)';
        }
        
        async function receiveMessage(message, senderKey) {
            if (message.sender === document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return message; // don't receive the message if it's from the current user (because we are already managing the message in the sendMessage function)
            return new Promise((resolve, reject) => {
                db.transaction(['keys'], 'readonly').objectStore('keys').get(senderKey).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the key doesn't exist, don't do anything
                    // sometimes there'll be an error with no message attached, it's usually because of the decrypt() using the wrong key
                    const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                        name: 'AES-GCM',
                        length: 256,
                    }, true, ['encrypt', 'decrypt']);
                    if (message.media) {
                        await subtle.decrypt({ // decrypt the image
                            name: 'AES-GCM',
                            iv: message.iv,
                        }, symmetricKey, new Uint8Array(message.media)).then(decrypted => {
                            decrypted = new TextDecoder().decode(decrypted);
                            message.media = decrypted; // set the image to the decrypted image (im still in shock that my code finally works)
                        });
                    }
                    if (message.text) {
                        message.text = new Uint8Array(message.text.split('').map(c => c.charCodeAt(0))); // decode the message
                        let decryptedMessage;
                        await subtle.decrypt({ // decrypt the message
                            name: 'AES-GCM',
                            length: 256,
                            iv: message.iv,
                        }, symmetricKey, message.text).then(decrypted => {
                            decryptedMessage = new TextDecoder().decode(decrypted);
                        });
                        decryptedMessage = decryptedMessage.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); // escape html characters to prevent an exploit
                        message.text = decryptedMessage;
                    }
                    message.date = new Date();
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message');
                    const currentChat = document.getElementById('currentChat').textContent;
                    if (message.sender !== currentChat && message.recipient !== currentChat && !message.recipient.includes(currentChat)) { // if the message isn't from the current chat, don't show it but save it locally and add a notification circle
                        saveMessage(message, message.sender); // in this case, the sender is the other user and the recipient is the current user
                        const chatlist = document.querySelector('.chat-list ul');
                        const friends = chatlist.getElementsByTagName('li');
                        for (let i = 0; i < friends.length; i++) {
                            if (friends[i].textContent === message.sender) {
                                friends[i].getElementsByClassName('message-notification-circle')[0].style.visibility = 'visible';
                            }
                        }
                        return;
                    } else if (message.recipient.includes('-') && message.recipient !== currentChat && message.sender !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) {
                        saveMessage(message, message.recipient); // in this case, the recipient = groupchat and the sender = the user who sent the message
                        const chatlist = document.querySelector('.chat-list ul');
                        const friends = chatlist.getElementsByTagName('li');
                        for (let i = 0; i < friends.length; i++) {
                            if (friends[i].textContent === message.recipient) {
                                friends[i].getElementsByClassName('message-notification-circle')[0].style.visibility = 'visible';
                            }
                        }
                        return;
                    }
                    messageElement.innerHTML = getMessageHTML(message);
                    twemoji.parse(messageElement, {
                        folder: 'svg',
                        ext: '.svg'
                    });
                    messagesContainer.appendChild(messageElement);
                    if (message.media) {
                        const imgElement = messageElement.querySelector('img');
                        if (imgElement) {
                            imgElement.addEventListener('load', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                        const videoElement = messageElement.querySelector('video');
                        if (videoElement) {
                            videoElement.addEventListener('loadedmetadata', () => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom
                            });
                        }
                    } else messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                    document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when message is received
                    resolve(message);
                };
            })
            return message;
        }

        function saveMessage(message, username) { // save the message in the indexedDB (essentially local storage)
            const transaction = db.transaction(['messages'], 'readwrite');
            const store = transaction.objectStore('messages');
            const data = {
                username, // the username of the user that the messages are for
                messages: [message]
            };
            store.get(username).onsuccess = (event) => {
                if (event.target.result) {
                    data.messages = event.target.result.messages;
                    data.messages.push(message);
                }
                store.put(data);
            };
        }

        function parseExpirationPeriod(period) {
            const unit = period.slice(-1);
            const value = parseInt(period.slice(0, -1), 10);

            switch (unit) {
                case 'h':
                    return value * 60 * 60 * 1000; // hours to milliseconds
                case 'd':
                    return value * 24 * 60 * 60 * 1000; // days to milliseconds
                case 'w':
                    return value * 7 * 24 * 60 * 60 * 1000; // weeks to milliseconds
                case 'm':
                    return value * 60 * 1000; // minutes to milliseconds
                default:
                    return 0; // default to 0 if the unit is not recognized
            }
        }

        function checkExpiredMessages() {
            db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent).onsuccess = (event) => {
                if (!event.target.result) return;
                if (!event.target.result.settings) event.target.result.settings = {autoDeleteMessages: 'never'}; 
                const expirationPeriod = event.target.result.settings.autoDeleteMessages;
                if (expirationPeriod === 'never') return; // if the expiration period is set to never, don't do anything
                const expirationTime = parseExpirationPeriod(expirationPeriod);
                const now = Date.now();

                const transaction = db.transaction(['messages'], 'readwrite');
                const store = transaction.objectStore('messages');
                const request = store.getAll();

                request.onsuccess = (event) => {
                    const messageKeys = event.target.result;
                    messageKeys.forEach(messageKey => {
                        const filteredMessages = messageKey.messages.filter(message => now - message.date <= expirationTime);
                        if (filteredMessages.length !== messageKey.messages.length) {
                            messageKey.messages = filteredMessages;
                            store.put(messageKey);
                        }
                    });
                };

                request.onerror = (event) => {
                    console.error('Failed to check expired messages:', event.target.errorCode);
                };
            }
        }

        // interval to check every once in a while if any messages are expired and delete them (this might not be the best way to do it but if there's a better way let me know lol)
        setInterval(checkExpiredMessages, 30 * 60 * 1000); // 30 * 60 * 1000 = 30 minutes

        async function sendMessage() {
            let messageText = messageInput.value;
            if (messageText) {
                db.transaction(['keys'], 'readonly').objectStore('keys').get(document.getElementById('currentChat').textContent).onsuccess = async (event) => {
                    if (!event.target.result) return; // if the public key doesn't exist, don't send the message
                    const symmetricKey = await subtle.importKey('jwk', event.target.result.symmetricKey, {
                        name: 'AES-GCM',
                        length: 256,
                    }, true, ['encrypt', 'decrypt']);
                    const encodedMessage = new TextEncoder().encode(messageText); // encode the message (because apparently that's how you do it in subtlecrypto)
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // generate an initialization vector
                    const encrypted = await subtle.encrypt({  // encrypt the message
                        name: 'AES-GCM',
                        iv
                    }, symmetricKey, encodedMessage);
                    const data = {
                        text: String.fromCharCode.apply(null, new Uint8Array(encrypted)), // ngl i don't know what the fromCharCode.apply thing does but it works so i'm not gonna touch it
                        recipient: document.getElementById('currentChat').textContent,
                        iv
                    }
                    socket.emit('message', data, (response) => { // send message to server
                        if (response.text) { // change response texts back to messageText because the server sends the message back with the base64 encoded + encrypted message
                            response.text = messageText;
                        } else if (response.message && response.message.text) {
                            response.message.text = messageText;
                        }
                        if (response.error) { // if the message fails to send (according to the server)
                            console.error(response.error);
                            const message = response.message;
                            const messageElement = document.createElement('div');
                            messageElement.classList.add('message');
                            messageElement.innerHTML = getMessageHTML(message);
                            twemoji.parse(messageElement, {
                                folder: 'svg',
                                ext: '.svg'
                            });
                            messagesContainer.appendChild(messageElement);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            messageInput.value = ''; // clear the input field
                            messageError(message);
                        } else { // if the message is sent successfully (hopefully)
                            const message = response;
                            const messageElement = document.createElement('div');
                            messageElement.classList.add('message');
                            messageElement.innerHTML = getMessageHTML(response);
                            twemoji.parse(messageElement, {
                                folder: 'svg',
                                ext: '.svg'
                            });
                            messagesContainer.appendChild(messageElement);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                            messageInput.value = ''; // clear the input field
                            saveMessage(message, message.recipient); // saving the message, the recipient would be the other user and the sender would be the current user
                        }
                    });
                }
            }
        }

        function listChat(name) {
            const li = document.createElement('li');
            const notificationCircle = document.createElement('span');
            notificationCircle.classList.add('message-notification-circle');
            notificationCircle.style.visibility = 'hidden';
            li.textContent = name;
            li.addEventListener('click', async () => { // switch the chat to the selected friend
                messageInput.removeAttribute('disabled'); // enable the message input field
                document.getElementById('upload').removeAttribute('disabled'); // enable the upload button
                document.getElementById('typingIndicator').style.display = 'none'; // stop typing indicator when switching chats
                document.getElementById('create-gc').style.display = 'block'; // show the create groupchat button
                currentChat.textContent = name;
                document.getElementById('status').textContent = sessionStorage.getItem(name) || ''; // set status of the user
                messagesContainer.innerHTML = ''; // Clear existing messages
                const messagesTransaction = db.transaction(['messages'], 'readonly');
                const messagesStore = messagesTransaction.objectStore('messages');
                const messagesRequest = messagesStore.get(name);

                messagesRequest.onsuccess = (event) => { // after the messages are grabbed from storage, display them
                    if (!event.target.result) return;
                    const messages = event.target.result.messages || [];
                    messages.forEach(message => {
                        if (message.sender !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent && message.recipient !== document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent) return; // only show messages that are sent to or from the current user
                        const messageElement = document.createElement('div');
                        messageElement.classList.add('message');
                        messageElement.innerHTML = getMessageHTML(message);
                        twemoji.parse(messageElement, {
                            folder: 'svg',
                            ext: '.svg'
                        });
                        messagesContainer.appendChild(messageElement);
                        if (message.media) {
                            const imgElement = messageElement.querySelector('img');
                            if (imgElement) {
                                imgElement.addEventListener('load', () => {
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                });
                            }
                            const videoElement = messageElement.querySelector('video');
                            if (videoElement) {
                                videoElement.addEventListener('loadedmetadata', () => {
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                });
                            }
                        } else messagesContainer.scrollTop = messagesContainer.scrollHeight; // scroll to the bottom of the messages
                    });
                };
                notificationCircle.style.visibility = 'hidden'; // hide the notification circle when the chat is opened
                messageInput.focus();
            });
            return {li, notificationCircle};
        }

        async function refresh() {
            try {
                await init();
                refreshPromise = new Promise(async (resolve) => {
                const modal = document.getElementById('mediaModal');
                const modalMedia = document.createElement('div');
                modalMedia.id = 'modalMedia';
                document.body.addEventListener('click', (event) => { // "event delegation" or whatever the fuck that means
                    if (event.target.tagName === 'IMG' && event.target.id !== 'modalMedia' && event.target.getAttribute('class') !== 'emoji') {
                        modal.style.display = 'block';
                        const img = document.createElement('img')
                        img.classList.add('media-modal')
                        img.src = event.target.src;
                        modal.appendChild(modalMedia).appendChild(img)
                    } else if (event.target === modal) {
                        modalMedia.replaceChildren('');
                        closeModal();
                    }
                });
                const username = document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent; // current user
                db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                    if (!event.target.result || !event.target.result.privateKey) { // if the user isn't in store, generate a key pair
                        const keyPair = await subtle.generateKey({ // generate key pair (we will need to later make checks to see if the key pair doesn't exist and generate it if it doesn't + tell the server to send the public key to the friends)
                            name: 'RSA-OAEP',
                            modulusLength: 2048,
                            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                            hash: 'SHA-256',
                        }, true, ["encrypt","decrypt"]);
                        userPrivateKey = keyPair.privateKey;
                        userPublicKey = keyPair.publicKey;
                        savePrivateKey(username, await subtle.exportKey('jwk', userPrivateKey));
                        console.log('Private key saved');
                        socket.emit('save-public-key', JSON.stringify(await subtle.exportKey('jwk', userPublicKey))); // send the public key to the server
                    } else { // if the user is in the store, load the key
                        db.transaction(['keys'], 'readonly').objectStore('keys').get(username).onsuccess = async (event) => {
                            if (!event.target.result) return;
                            userPrivateKey = await subtle.importKey('jwk', event.target.result.privateKey, {
                                name: 'RSA-OAEP',
                                hash: 'SHA-256',
                            }, true, ['decrypt']);
                            // let's check if the private key matches the server-saved public key, we'll ask the server for our own public key
                            socket.emit('request-public-key', username, async (response) => {
                                if (response.error) return alert(response.error);
                                const publicKey = await subtle.importKey('jwk', JSON.parse(JSON.parse(response.publicKey)), {
                                    name: 'RSA-OAEP',
                                    hash: 'SHA-256',
                                }, true, ['encrypt']);
                                const verificationMessage = new TextEncoder().encode('This is a verification message');
                                const encrypted = await subtle.encrypt({ // using encrypt because you can't sign with rsa-oaep
                                    name: 'RSA-OAEP',
                                }, publicKey, verificationMessage);
                                await subtle.decrypt({ // using decrypt because you can't verify with rsa-oaep
                                    name: 'RSA-OAEP',
                                }, userPrivateKey, encrypted).catch(err => { // failed to decrypt, the private key doesn't match the public key
                                    let store = db.transaction(['keys'], 'readwrite').objectStore('keys');
                                    store.delete(username).onsuccess = () => { // delete the private key from the store
                                        console.log('Private key does not match public key, regenerating key pair');
                                        return refresh();
                                    };
                                });
                            });
                            console.log('Private key loaded');
                        }
                    }
                }
                const chatlist = document.querySelector('.chat-list ul');
                const currentChat = document.getElementById('currentChat');
                chatlist.innerHTML = ''; // Clear existing list items
                const groupchatsTransaction = db.transaction(['keys'], 'readonly');
                const groupchatsStore = groupchatsTransaction.objectStore('keys');
                const groupchatsRequest = groupchatsStore.getAll();
                groupchatsRequest.onsuccess = async (event) => {
                    const groupchats = event.target.result;
                    groupchats.forEach(groupchat => {
                        if (groupchat.type !== 'group') return;
                        const {li, notificationCircle} = listChat(groupchat.username);
                        li.addEventListener('contextmenu', (event) => { // right click to open context menu
                            event.preventDefault();
                            const contextMenu = document.getElementById('group-context-menu');
                            contextMenu.style.display = 'block';
                            contextMenu.style.left = event.clientX + 'px';
                            contextMenu.style.top = event.clientY + 'px';
                            contextMenu.group = groupchat.username; // groupchat.username is the name of the groupchat
                        });
                        chatlist.appendChild(li);
                        li.appendChild(notificationCircle);
                    }
                )};

                let response = await fetch('/friends', { // Fetch the list of friends from the server
                    method: 'GET',
                    credentials: "include",
                })
                
                if (!response.ok) {
                    throw new Error('Failed to fetch friends');
                }

                let friends = await response.json();
                localFriends = friends; // store the friends locally
                await friends.forEach(friend => { // for every friend in the list, create a list item and append it to the chatlist
                    getStatus(friend);
                    fetchProfilePicture(friend);
                    const transaction = db.transaction(['keys'], 'readonly');
                    const store = transaction.objectStore('keys');
                    const request = store.get(friend);
                    request.onsuccess = async (event) => { // check for a saved public key for the friend and request it if it doesn't exist
                        if (!event.target.result || !event.target.result.publicKey) {
                            socket.emit('request-public-key', friend, (response) => {
                                if (response.error) return alert(response.error);
                                const publicKey = JSON.parse(JSON.parse(response.publicKey)); // insert mandatory "WHY DO I HAVE TO PARSE THIS TWICE" comment here
                                savePublicKey(friend, publicKey); // save the public key in indexedDB
                                createSymmetricKey(friend, publicKey); // create a symmetric key for the chat with the friend
                            });
                        }
                    };
                    const {li, notificationCircle} = listChat(friend);
                    li.addEventListener('contextmenu', (event) => { // right click to open context menu
                        event.preventDefault();
                        const contextMenu = document.getElementById('friend-context-menu');
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = event.clientX + 'px';
                        contextMenu.style.top = event.clientY + 'px';
                        contextMenu.friend = friend;
                    });
                    chatlist.appendChild(li);
                    li.appendChild(notificationCircle);
                    socket.emit('check-online', friend, (response) => { // check if the friend is online to show the online status
                        if (response) { // response = true if the friend is online
                            li.style.color = 'green';
                        }
                    });
                });
                document.addEventListener('click', (event) => { // close context menu when clicking outside of it
                    const contextMenu = document.getElementById('friend-context-menu');
                    if (event.target !== contextMenu && !contextMenu.contains(event.target)) {
                        contextMenu.style.display = 'none';
                    }
                });
                resolve();
                // doing this after the resolve because it's not necessary to wait for it
                response = await fetch('/friend-requests', { // i could probably just call the friends function here but i'd have to do scope stuff and who do you think i am, a professional?
                    method: 'GET',
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                friends = await response.json();
                const notificationCircle = document.querySelector('.notification-circle');
                if (friends.length > 0) { // if there are friend requests, display a notification circle
                    notificationCircle.style.display = 'block';
                } else {
                    notificationCircle.style.display = 'none';
                }
            })
            } catch (err) {
                console.error(err);
            }
        }

        async function friends() {
            document.getElementById('friendsModal').style.display = 'block'; // used to display the modal
            try {
                const response = await fetch('/friend-requests', { // Fetch the friend requests from the server
                    method: 'GET',
                    credentials: "include",
                });
                if (!response.ok) {
                    throw new Error('Failed to fetch friend requests');
                }

                const friends = await response.json();
                const friendRequestsList = document.querySelector('#friendsModal ul');
                friendRequestsList.innerHTML = ''; // Clear existing list items

                friends.forEach(friend => { // for every friend in the list, create a list item and append it to the friendRequestsList
                    const li = document.createElement('li');                    
                    li.textContent = friend;

                    const acceptButton = document.createElement('button');
                    acceptButton.textContent = 'Accept';
                    acceptButton.classList.add('friend-request-button', 'accept-button');
                    acceptButton.addEventListener('click', () => handleFriendRequest(friend, true));

                    const rejectButton = document.createElement('button');
                    rejectButton.textContent = 'Reject';
                    rejectButton.classList.add('friend-request-button', 'reject-button');
                    rejectButton.addEventListener('click', () => handleFriendRequest(friend, false));
                    
                    li.appendChild(acceptButton);
                    li.appendChild(rejectButton);
                    friendRequestsList.appendChild(li);
                });

                if (friends.length === 0) { // if there are no friend requests, display a message
                    const li = document.createElement('li');
                    li.textContent = 'No friend requests';
                    friendRequestsList.appendChild(li);
                    document.querySelector('.notification-circle').style.display = 'none'; // hide the notification circle
                }
            } catch (err) {
                console.error(err);
            }
        }

        async function handleFriendRequest(friend, accept) {
            try {
                const response = await fetch('/friend-requests', { // fetch the friend requests from the server
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(friend)}&accept=${accept}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to handle friend request');
                }

                const friendRequestsList = document.querySelector('#friendsModal ul');
                friends(); // refresh the friend requests
                refresh(); // refresh the chat list
            } catch (err) {
                console.error(err);
            }
        }

        async function removeFriend() {
            try {
                const contextMenu = document.getElementById('friend-context-menu');
                const response = await fetch('/remove-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(contextMenu.friend)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to remove friend');
                }

                localFriends = localFriends.filter(f => f !== contextMenu.friend);
                contextMenu.style.display = 'none';
                const chatlist = document.querySelector('.chat-list ul');
                refresh();
            } catch (err) {
                console.error(err);
            }
        }

        function saveStatus() {
            const status = document.getElementById('statusInput').value;
            const transaction = db.transaction(['keys'], 'readwrite');
            const store = transaction.objectStore('keys');
            store.get(document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent).onsuccess = async (event) => {
                event.target.result.status = status;
                store.put(event.target.result);
                socket.emit('status', status);
            }
        }

        async function getStatus(user) {
            try {
                const response = await fetch(`/status?user=${user}`, {
                    method: 'GET',
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch status');
                }

                if (response.status === 204) return ''; // if the status is empty, return an empty string

                const status = await response.text();
                sessionStorage.setItem(user, status);
                return status;
            } catch(err) {
                console.error(err);
            }
        }

        async function fetchProfilePicture(username) {
            if (profilePicturesCache[username]) return profilePicturesCache[username];
            try {
                const response = await fetch(`/profile-picture?user=${username}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch profile picture');
                }

                const data = await response.json();
                const dataUrl = `data:${data.mimetype};base64,${data.data}`;
                profilePicturesCache[username] = dataUrl;
                return dataUrl;
            } catch (err) {
                console.error('Error fetching profile picture:', err);
                return null;
            }
        }

        function Profile() {
            try {
                const profileModal = document.getElementById('profileModal');
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                store.get(document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent).onsuccess = async (event) => {
                    document.getElementById('statusInput').value = event.target.result.status || '';
                    try {
                        const response = await fetch('/profile-picture', {
                            method: 'GET',
                            credentials: "include",
                        });

                        profileModal.style.display = 'block';

                        const data = await response.json();
                        const dataUrl = `data:${data.mimetype};base64,${data.data}`;
                        document.getElementById('profilePicturePreview').src = dataUrl || '';
                    } catch(err) {
                        console.error('Failed to fetch profile picture:', err);
                    }
                }
            } catch(err) {
                console.error('Failed to fetch profile:', err);
            }
        }

        function settings() {
            try {
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                store.get(document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent).onsuccess = async (event) => {
                    document.getElementById('settingsModal').style.display = 'block';
                    const settings = event.target.result.settings || {};

                    if (settings.autoDeleteMessages) {
                        document.getElementById('autoDeleteMessages').value = settings.autoDeleteMessages;
                    } else {
                        document.getElementById('autoDeleteMessages').value = 'never';
                    }
                }
            } catch(err) {
                console.error('Failed to fetch settings:', err);
            }
        }

        function saveOptions() {
            try {
                const options = document.getElementsByClassName('option');
                const transaction = db.transaction(['keys'], 'readwrite');
                const store = transaction.objectStore('keys');
                store.get(document.getElementsByClassName('user-actions')[0].getElementsByTagName('h4')[0].textContent).onsuccess = async (event) => {
                    const settings = event.target.result.settings || {};
                    for (let i = 0; i < options.length; i++) {
                        settings[options[i].id] = options[i].value;
                    }
                    event.target.result.settings = settings;
                    store.put(event.target.result); // if only store.add() would just work instead of doing put
                }
            } catch(err) {
                console.error('Failed to save settings:', err);
            }
        }

        function leaveGroupchat() { // the reason this is socket.emit and not fetch is because this is to leave the room on socket.io, using fetch would not be as efficient
            try {
                const contextMenu = document.getElementById('group-context-menu');
                const groupName = contextMenu.group;
                // Emit the leave-groupchat event to the server
                socket.emit('leave-groupchat', groupName, (response) => {
                    contextMenu.style.display = 'none';
                    if (response.error) return alert(response.error);
                    const chatlist = document.querySelector('.chat-list ul');
                    if (response.success) {
                        const transaction = db.transaction(['keys'], 'readwrite');
                        const store = transaction.objectStore('keys');
                        store.delete(groupName);
                        refresh();
                    }
                });
            } catch (err) {
                console.error(err);
            }
        }


        function toggleEmojiPicker() {
            const emojiPicker = document.getElementById('emoji-picker');
            if (emojiPicker.style.display === 'none') {
                emojiPicker.style.display = 'block';
            } else {
                emojiPicker.style.display = 'none';
            }
        }

        let emojis;

        async function populateEmojiPicker() {
            const emojiList = document.getElementById('emoji-list');
            let emojisFetch = await fetch('/emojis.json');
            emojis = await emojisFetch.json();
            emojis = emojis.emojis;
            emojis.forEach(emoji => {
                const emojiButton = document.createElement('button');
                emojiButton.innerHTML = emoji.emoji;
                emojiButton.classList.add('emoji-button');
                emojiButton.onclick = () => insertEmoji(emoji);
                emojiList.appendChild(emojiButton);
                twemoji.parse(emojiButton);
            });
        }

        function insertEmoji(emoji) {
            const messageInput = document.getElementById('messageInput');
            messageInput.value += emoji;
            messageInput.focus();
        }

        function filterEmojis() {
            const searchValue = document.getElementById('emoji-search').value.toLowerCase();
            const emojiList = document.getElementById('emoji-list');
            emojiList.innerHTML = ''; // Clear the current list

            const filteredEmojis = emojis.filter(emojiObj => {
                return emojiObj.shortname.includes(searchValue);
            });

            filteredEmojis.forEach(emojiObj => {
                const emojiButton = document.createElement('button');
                emojiButton.innerText = emojiObj.emoji;
                emojiButton.classList.add('emoji-button');
                emojiButton.onclick = () => insertEmoji(emojiObj.emoji);
                emojiList.appendChild(emojiButton);
            });
        }
        
        function toggleDropdown() {
            var dropdownContent = document.getElementById("dropdown-content");
            if (dropdownContent.style.display === "none") {
                dropdownContent.style.display = "flex";
                populateDropdown();
            } else {
                dropdownContent.style.display = "none";
            }
        }

        function populateDropdown() {
            let form = document.getElementById("friends-form");
            form.innerHTML = '';

            localFriends.forEach(friend => {
                let checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = friend;
                checkbox.value = friend;
                checkbox.id = friend;

                let label = document.createElement('label');
                label.htmlFor = friend;
                label.appendChild(document.createTextNode(friend));

                form.appendChild(checkbox);
                form.appendChild(label);
                form.appendChild(document.createElement('br'));
            });
        }

        async function blockUser() {
            try {
                const contextMenu = document.getElementById('friend-context-menu');
                const response = await fetch('/blocked-users', {
                    method: 'POST',
                    credentials: "include",
                    body: `user=${encodeURIComponent(contextMenu.friend)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to block user');
                }

                localFriends = localFriends.filter(f => f !== contextMenu.friend);
                contextMenu.style.display = 'none';
                refresh();
            } catch (err) {
                console.error(err);
            }
        }

        async function blockedUsers() {
            document.getElementById('blockedModal').style.display = 'block';
            try {
                const response = await fetch('/blocked-users', {
                    method: 'GET',
                    credentials: "include",
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch blocked users');
                }

                const blockedUsers = await response.json();
                const blockedUsersList = document.querySelector('#blockedModal ul');

                blockedUsers.forEach(user => {
                    const li = document.createElement('li');
                    li.textContent = user;

                    const unblockButton = document.createElement('button');
                    unblockButton.textContent = 'Unblock';
                    unblockButton.classList.add('friend-request-button');
                    unblockButton.addEventListener('click', () => unblockUser(user));

                    li.appendChild(unblockButton);
                    blockedUsersList.appendChild(li);
                });

                if (blockedUsers.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'No blocked users';
                    blockedUsersList.appendChild(li);
                }
            } catch(err) {
                console.error(err);
            }
        }

        async function unblockUser(username) {
            try {
                const response = await fetch('/blocked-users', {
                    method: 'POST',
                    credentials: "include",
                    body: `user=${encodeURIComponent(username)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded',
                    },
                });

                if (!response.ok) {
                    throw new Error('Failed to unblock user');
                }

                blockedUsers(); // refresh the blocked users
            } catch (err) {
                console.error(err);
            }
        }

        function addUser() { // used to display the add friend modal
            document.getElementById('addUserModal').style.display = 'block';
        }

        function closeModal() { // just closes the modals
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
            });
        }

        async function submitUser() { // used for adding friends
            const username = document.getElementById('usernameInput').value;
            if (username) {
                const response = await fetch('/add-friend', {
                    method: 'POST',
                    credentials: "include",
                    body: `friend=${encodeURIComponent(username)}`,
                    headers: {
                        'Content-type': 'application/x-www-form-urlencoded', // applcation/json doesn't work, i don't know why, i don't care why, i just want it to work. it's 7:40 am and i haven't slept
                    },
                })
                
                if (response.ok) {
                    alert(`User ${username} added!`);
                } else if (response.status === 404) {
                    alert(`User ${username} not found!`);
                } else if (response.status === 400) {
                    alert(`User ${username} is already a friend!`);
                } else {
                    alert('Trouble adding user ' + username);
                }
                document.getElementById('usernameInput').value = '';
                closeModal();
            }
        }
        refresh(); // refresh the chat list
    </script>
</body>
</html>